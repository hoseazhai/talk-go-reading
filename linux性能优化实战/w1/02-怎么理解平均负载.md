## 问题引入
近期在读倪鹏飞的linux性能优化一书，作为巩固相关知识，开篇就是平均负载相关的内容，其中提到了ps命令，在日常的工作中ps命令也确实是最为常用的命令，但是真的对此有所了解吗？

## Linux下的进程状态
在linux下有5中进程状态分别为
1.运行 R（正在运行或在运行队列中等待）
2.中断 S（休眠中，受阻，在等待某个条件的形成或接收到信号）
3.不可中断 D（收到信号不可唤醒和不可运行，进程必须等待直到有中断发生）
4.僵死 Z（进程已终止，但进程描述符存在，直到父进程调用wait4（）系统调用后释放）
5.停止 T（进程收到sigstop，sigstp，sigtin，sigtou信号后停止运行）


### 睡眠状态
睡眠状态分为可中断与不可中断 对应的 符号为S和D

### 中断睡眠状态
表示进程在等待时间片段或者某个特定的事件，一旦事件发生，进程会从可中断状态中退出，

### 不可中断之睡眠状态 D
此状态的进程不会处理任何信号，而仅在等待的资源可用或者设置的超时时间超时后退出，此状态通常和设备驱动等待磁盘或网络I/O有关，
由于处于不可中断之睡眠状态的进程不会处理任何信号，所以kill -9 也杀不掉，解决此进程的办法只有两个
+ 等待资源可用
+ 重启系统

### 僵死

分为僵尸进程与孤儿进程

+ 僵尸进程：当进程退出但父进程并没有调用wait或者waitpid获取子进程的状态信息时，就会产生僵尸进程
+ 孤儿进程：当一个父进程退出，而它的一个或多个子进程还在运行，那个子进程金辉变成孤儿进程，被init进程管理。

## ps命令使用指南

+ a  显示所有进程
+ -a 显示同一终端下的所有程序
+ -A 显示所有进程
+ c  显示进程的真实名称
+ -N 反向选择
+ -e 等于“-A”
+ e  显示环境变量
+ f  显示程序间的关系
+ -H 显示树状结构
+ r  显示当前终端的进程
+ T  显示当前终端的所有程序
+ u  指定用户的所有进程   ps -u root
+ -au 显示较详细的资讯
+ -aux 显示所有包含其他使用者的行程
+ -C<命令> 列出指定命令的状况
+ --lines<行数> 每页显示的行数
+ --width<字符数> 每页显示的字符数
+ --help 显示帮助信息
+ --version 显示版本显示


例子及其说明: ps -aux

```go
[root@iz2zef6ny09ico8j2nv2g0z ~]# ps -aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1  43196  3576 ?        Ss   3月17   0:28 /usr/lib/syste
root         2  0.0  0.0      0     0 ?        S    3月17   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S    3月17   0:07 [ksoftirqd/0]
```
每一列的说明

USER：该 process 属于那个使用者账号的

PID ：该 process 的号码

%CPU：该 process 使用掉的 CPU 资源百分比

%MEM：该 process 所占用的物理内存百分比

VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)

RSS ：该 process 占用的固定的内存量 (Kbytes)

TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。

STAT：该程序目前的状态，主要的状态有

R ：该程序目前正在运作，或者是可被运作

S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。

T ：该程序目前正在侦测或者是停止了

Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态
<    高优先级
N    低优先级
L    有些页被锁进内存
s    包含子进程
+    位于后台的进程组；
l    多线程，克隆线程  multi-threaded (using CLONE_THREAD, like NPTL pthreads do)

START：该 process 被触发启动的时间

TIME ：该 process 实际使用 CPU 运作的时间

COMMAND：该程序的实际指令

## stress
	linux系统压力测试工具
	使用说明：
        -? 显示帮助信息
		-v 显示版本号
		-q 不显示运行信息
		-n，--dry-run 显示已经完成的指令执行情况
		-t --timeout N 指定运行N秒后停止
		   --backoff N 等待N微妙后开始运行
		-c --cpu 产生n个进程 每个进程都反复不停的计算随机数的平方根
		-i --io  产生n个进程 每个进程反复调用sync()，sync()用于将内存上的内容写到硬盘上
		-m --vm n 产生n个进程,每个进程不断调用内存分配malloc和内存释放free函数
		   --vm-bytes B 指定malloc时内存的字节数 (默认256MB)
		   --vm-hang N 指示每个消耗内存的进程在分配到内存后转入休眠状态，与正常的无限分配和释放内存的处理相反，这有利于模拟只有少量内存的机器
		-d --hadd n 产生n个执行write和unlink函数的进程
		   --hadd-bytes B 指定写的字节数，默认是1GB
		   --hadd-noclean 不要将写入随机ASCII数据的文件Unlink

		时间单位可以为秒s，分m，小时h，天d，年y，文件大小单位可以为K，M，G
	例子：
		stress --cpu 1 --timeout 600  模拟一个CPU使用100%
		stress -i 1 --timeout 600   模拟IO密集型  stress-ng -i 1 --hdd 1 --timeout 600
		stress -c 8 --timeout 600 模拟8个进程
## mpstat
	多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
	使用说明：
		-u：默认的参数，显示各个进程的cpu使用统计
		-r：显示各个进程的内存使用统计
		-d：显示各个进程的IO使用情况
		-p：指定进程号
		-w：显示每个进程的上下文切换情况
		-t：显示选择任务的线程的统计信息外的额外信息
		-T { TASK | CHILD | ALL }
		这个选项指定了pidstat监控的。TASK表示报告独立的task，CHILD关键字表示报告进程下所有线程统计信息。ALL表示报告独立的task和task下面的所有线程。
		注意：task和子线程的全局的统计信息和pidstat选项无关。这些统计信息不会对应到当前的统计间隔，这些统计信息只有在子线程kill或者完成的时候才会被收集。
		-V：版本号
		-h：在一行上显示了所有活动，这样其他程序可以容易解析。
		-I：在SMP环境，表示任务的CPU使用率/内核数量
		-l：显示命令名和所有参数
	例子：
		mpstat -P ALL 5 1  输出所有内核，每隔5秒 输出一次 总共输出一次

## 概念
	1. 平均负载:单位时间内，系统处于可运行状态和不可中断状态的平均进程数即平均活跃进程数
	2. linux进程状态：
		可运行状态:正在使用CPU或者正在等待CPU的进程，通过进程查看处于R状态
		不可中断状态:正处于内核态关键流程中的进程，并且这些流程是不可打断的，常见的就是等待硬件设备的I/O响应，处于D状态，此状态实际上是系统对进程和硬件设备的一种保护机制
	3. 平均负载与CPU使用率的关系：
		平均负载：不仅包含了正在使用CPU的进程，还包括等待CPU和等待I/O的进程
		CPU使用率：是单位时间内CPU繁忙情况的统计，跟平均负载不一定完全对应
		例子：
			CPU密集型线程：使用大量CPU导致平均负载升高，此时两者是一致的
			I/O密集型：等待I/O导致平均负载升高，但CPU使用率不一定很高
			大量等待CPU的进程调度也会导致平均负载升高，此时的CPU使用率也会比较高
	4.总的逻辑 cpu 数 = 物理 cpu 数 * 每颗物理 cpu 的核心数 * 每个核心的超线程数


## 实用命令
	1.查看物理cpu个数：cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
	2.查看每个物理 cpu 中 核心数(core 数)：cat /proc/cpuinfo | grep "cpu cores" | uniq
	3.查看总的逻辑 cpu 数（processor 数）：cat /proc/cpuinfo| grep "processor"| wc -l
	4.查看cpu型号：cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
	5. uptime
		02:34:03 up 2 days, 20:14, 1 user, load average: 0.63, 0.83, 0.88
		系统当前时间  运行时间			正在登陆用户数		平均负载 1分钟/5分钟/15分钟
	6. 获取系统的cpu个数
		grep 'model name' /proc/cpuinfo | wc -l
	7. stress
		linux系统压力测试工具
	8. mpstat
		多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
	9. pidstat
		进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标
		例子：
			pidstat -u 5 1  输出cpu数据 每隔5秒输出一次 总共输出一次
	10. htop
	11. atop
	12. lsof
	13. top

## 经验

当平均负载高于CPU数量的70%的时候，就应该排查分析负载高的原因了，当然更好的方式，还是通过监控，然后与历史数据进行对比分析。
