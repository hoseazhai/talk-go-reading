## 09 | 基础篇：怎么理解Linux软中断

## 概念
+ 中断是一种异步的事件处理机制，可以提高系统的并发处理能力
+ 中断处理程序会打断其他进程的运行，为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快的运行。
+ 中断丢失：中断处理程序在响应中断时，会临时关闭中断，导致上一次中断处理完成之前其他中断都不能响应，可能造成中断丢失
+ 中断分类：中断处理过程分为两个阶段，分为上半部（硬中断）和下半部（软中断），
	+ 硬中断：用来快速处理中断，主要处理跟硬件紧密相关或时间敏感的工作，快速执行
	+ 软中断：用来延迟处理上半部未完成的工作，通常以内核线程的方式运行， 延迟执行
	举例说明：网卡接到数据包后，会通过硬件中断的方式，通知内核有新的数据，这时内核就应该调用中断处理程序来相应，对上班部来说，就是快速处理，把网卡的数据读取到内存中，然后更新一下硬件寄存器的状态。最后发送一个软中断，通知下半部做进一步处理。而下半部被软中断信号唤醒后，从内存中找到网络数据，按照网络协议栈，对数据解析处理，送到应用程序
+ 中断线程：硬中断会打断CPU正在运行的任务，然后立即执行中断处理程序，而下半部以内核线程方式运行，每个CPU都对应一个软中断内核线程。名字为ksoftirqd/CPU编号，如0号CPU为ksoftirqd/0

+ 软中断范围：不止包括中断处理程序的下半部，还包括内核自定义事件，比如内核调度，RCU(Read-Copy Update)锁等

+ 中断运行情况
	+ /proc/softirqs 提供了软中断的运行情况
	+ /proc/interrupts 提供了硬中断的运行情况

## 命令

### cat /proc/softirqs

```sh
root@devops-064167:/home/hero# cat /proc/softirqs
                    CPU0       CPU1       CPU2
          HI:          3          0          0
       TIMER:  280281009  243301213  214421595
      NET_TX:         43         22         28
      NET_RX:  201368538  125793287  103520820
       BLOCK:          0          0          0
BLOCK_IOPOLL:          0          0          0
     TASKLET:         33          0          2
       SCHED:  145306905   77203970   49752787
     HRTIMER:          0          0          0
         RCU:  149836830  135528437  121803583
```
+ HI 处理高优先级的tasklet
+ TIMER 和时钟中断相关的tasklet
+ NET_TX 把数据包传送到网卡
+ NET_RX 从网卡接受数据包
+ SCHED 内核调度
+ RCU锁

### 查看软中断的内核线程

 ```sh
$ ps aux | grep softirq
root         7  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/0]
root        16  0.0  0.0      0     0 ?        S    Oct10   0:01 [ksoftirqd/1]
 ```

 线程外名字有中括号，说明ps无法获取到命令行参数，一般的ps的输出中，名字包括在中括号中的，都是内核线程

