## 12 | 套路篇：CPU 性能优化的几个思路

## 性能优化方法论

动手之前的三个问题
+ 如何判断优化有效，并且优化后能提升多高的性能？
+ 性能问题通常不是独立的，有多个性能问题时，应该优先优化哪一个
+ 提升性能的方法不唯一，如何选择？


### 如何评估性能优化的效果
主要从这三个指标去分析：

+确定性能的量化指标。
+测试优化前的性能指标。
+测试优化后的性能指标。

#### 首先确定性能量化指标
不要局限在单一维度的指标上，至少从应用程序和系统资源两个维度,以web应用为例：
+ 应用程序的维度：吞吐量和请求延迟
+ C系统资源维度：CPU使用率

#### 测试优化前后的性能指标
主要通过相应的工具 来查看优化前后的指标状况，但特别需要注意：

+ 避免性能测试工具带来的干扰
+避免外部环境的变化影响性能指标

### 多个性能问题同时存在，如何选择

二八原则：80%的问题都是由20%的代码导致的

找到最重要的，可以最大程序提升性能的问题。

简化过程的方式：
+ 如果系统资源达到瓶颈，则首先优化系统资源问题
+ 针对不同类型的指标，首先优化那些由瓶颈导致的，性能指标变化幅度最大的问题，

### 多种优化方法如何选择

一般情况选择最大提升性能的方法，但性能优化也有成本。需要综合分析

## 优化案例（CPU优化）

### 应用程序优化：
+ 编译器优化：在编译阶段可以获得编译器的帮助，来提升性能，比如gcc提供了优化选项 -O2
+ 算法优化： 使用复杂度更低的算法，可以显著加快处理速度。
+ 异步处理： 使用异步处理，可以避免程序因为等待某个资源而一直阻塞，提升程序的并发处理能力
+ 多线程代替多进程：线程的上下文切换比进程的上下文切换更降低成本
+ 善用缓存：经常访问的数据或计算过程步骤，放到缓存中

### 系统优化

+ CPU绑定：把进程绑定到一个或多个CPU上，提高CPU缓存的命中率。减少跨CPU调度带来的上下文切换问题
+ CPU独占：跟CPU绑定类似，进一步将CPU分组，并通过CPU亲和性机制为其分配进程
+ 优先级调整：使用nice调整进程的优先级，正值调低优先级，负值调高优先级，适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心引用得到优先处理
+ 为进程设置资源限制：使用Linux cgroups来设置进程的CPU使用上限，防止由于某个应用自身的问题，而耗尽系统资源
+ NUMA（Non-Uniform Memory Access）优化：支持 NUMA 的处理器会被划分为多个 node，每个 node 都有自己的本地内存空间。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存。
+ 中断负载均衡：无论是软硬中断，它们的中断处理程序可能会耗费大量的COU，开启irqbalance服务或者配置smp_affinity，就可以把中断处理过程自动负载均衡到多个CPU上


## 重点：
	不要进行过早的系统优化




