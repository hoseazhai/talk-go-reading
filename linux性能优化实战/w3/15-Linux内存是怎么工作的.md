15 | 基础篇：Linux内存是怎么工作的？

## 内存

我们通常说的内存就是物理内存，也被称为主存，大多数计算机用的主存都是动态随机访问内存（DRAM），只有内核才可以直接访问物理内存

## 内存映射
linux内核为每个进程都提供了独立的虚拟地址空间，并且这个地址空间是连续的，这样进程就可以很方便的访问虚拟内存

虚拟地址空间内部，又被分为内核空间和用户空间

0xFFFFFFFF						0xFFFFFFFFFFFFFFFFF				
内核空间1G			 				内核空间128T
0xC0000000						0xFFFF8000000000000
									 未定义
								0x00007FFFFFFFFF000
用户空间3G							用户空间128T

0x0 								0x0

32位地址空间						64位地址空间


+ 所有进程的虚拟内存加起来，自然要不实际的物理内存大的多，所以并不是所有的虚拟内存都会分配物理内存。

内存映射：将虚拟内存地址映射到物理内存地址，为了完成映射，内核为每个进程都维护了一张页表，记录了虚拟地址和物理地址的映射关系，页表实际上存储在CPU的内存管理单元MMU中

缺页异常： 当进程访问的虚拟地址在页表中查不到时，产生此问题，之后会进入内核空间分配物理内存，更新进程页表，最后返回用户空间，回复进程运行

TLB（Translation Lookaside Buffer，转译后备缓冲器）：MMU中页表的高速缓存，进程的虚拟地址空间是独立的，而TLB的访问速度又比MMU快的多。所以可以通过减少进程上下文切换，减少TLB的刷新次数，从而提高TLB缓存的使用率，提高CPU对内存的访问性能

最小映射单位：通常是4KB，而每一次内存映射都需要关联4KB或者4KB整数倍的内存空间


采用内存映射所引入的问题：页的大小只有4KB，导致页表就会变得很大
解决方式：多级页表和大页

多级页表：把内存分成区块来管理，将原来的映射关系改成区块索引和区块内的偏移，由于虚拟内存空间通常只用了很少一部分，那么，多级页表就只保存这些使用中的区块，从而减少了页表的项数。Linux用的正是四级页表来管理内存页，虚拟地址被分为5个部分，前4个表项用于选择页，最后一个索引表示页内偏移 
+ PGD	PUD	PMD	PTE	Offset

大页：比普通页更大的内存块，常见的有2MB和1GB，

## 虚拟内存空间分布

这里所说的内存空间分布，主要为用户空间分布，所以忽略了最高的内核空间，从低到高依次为
+ 只读段：包括代码和常量等
+ 数据段：包括全局变量
+ 堆：包括动态分配的内存，从低地址开始向上增长。
+ 文件映射段，包括动态库，共享内存等，从高地址往下增长
+ 栈：包括拒不变量和函数调用的上下文等，大小固定，一般是8MB

说明：其中堆和文件映射段的内存时动态分配的

## 内存分配和回收

### 内存分配

malloc（）是C标准库提供的内存分配函数，对应到系统调用上有两种实现方式：brk（）和mmap（）

+ brk（）：主要针对小块内存（小于128K），通过移动堆顶的位置来分配内存。这些内存释放后并不会立即归还系统，而是被缓存可重复利用
	+ 优点：减少缺页异常的发生，提高内存访问效率
	+ 缺点： 在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片
+ mmap（）：大块内存（大于128K），在文件映射段找一块空闲内存进行分配
	+ 优先：释放后会直接归还系统。
	+ 缺点：每次mmap都会发生缺页异常，在内存工作繁忙时，频繁的内存分配导致大量的缺页异常，使内核的管理负担增大。

注意： 当发生了以上两种调用时，其实并没有真正分配内存。这些内存都只在首次访问时才分配。

伙伴系统： linux用伙伴系统来管理内存分配，以页为单位来管理，并且会通过相邻页的合并，减少内存碎片化。

+ 分配不到1K内存时的过程：用户空间的malloc通过brk（）分配内存，在释放时并不立即归还系统，而是缓存起来重复利用，在内核空间，LInux则通过slab分配器来管理小内存，可以把slab看成构建在伙伴系统上的一个缓存，主要作用就是分配并释放内核中的小对象

### 内存回收

+ 回收缓存：使用LRU（Least Recently Used）算法，回收最近使用最少的内存页面
+ 回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中，用到交换分区（swap），
+ 杀死进程:内存紧张时系统通过OOM（Out of Memory），直接杀掉占用大量内存的进程


swap：swap其实就是讲一块磁盘空间当做内存来使用，可以把进程暂时不用的数据存储到磁盘中（这个过程称为换出），当进程访问这些内存时，再从磁盘读取这些数据到内存（换入），注意，通常在内存不足时，才会发生swap交换，swap由于是磁盘上的读写，所以会导致严重的内存性能问题

OOM（Out of Memory）：内核提供的一种保护机制，监控进程的内存使用情况，并使用oom_score为每个进程的内存使用情况进行评分，进程消耗内存越大，oom_score就越大，进程运行占用的CPU越多，oom_score就越小，为了实际工作，可通过proc文件系统，手动设置进程的oom_adj，从而调整进程的oom_socre,其中oom_adj的范围为[-17,15]，数值越大，表示进程越容易被OOM杀死，数值越小，表示进程越不容易被OOM杀死，-17表示禁止OOM，如下为调整sshd进程的oom_adj为16的例子

```sh
echo -16 > /proc/$(pidof sshd)/oom_adj
```

## 查看内存使用情况

### free命令

```sh
root@devops-064167:/home/hero# free
              total        used        free      shared  buff/cache   available
Mem:        8010456     2537856      603388      465912     4869212     4686948
Swap:             0           0           0
```
+ total:总内存大小
+ used: 已使用内存大小，包含了共享内存
+ free: 未使用的内存你大小
+ shared: 共享内存大小
+ buff/cache: 缓存和缓冲区的大小
+ available: 新进程可用内存的大小，不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大

### top输出内存使用

```sh
top - 15:03:42 up 81 days, 22:26,  1 user,  load average: 0.29, 0.41, 0.33
Tasks: 269 total,   1 running, 268 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.7 us,  0.4 sy,  0.0 ni, 98.8 id,  0.1 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  8010456 total,   591828 free,  2549112 used,  4869516 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  4675700 avail Mem

   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
256658 root      20   0 1670332 160148  30280 S   5.0  2.0   7452:27 docke
```
+ VIRT:进程虚拟内存的大小，只要是进程申请过的内存，几遍还没有真正分配物理内存，也会计算在内
+ RES:常驻内存大小，也就是进程实际使用的物理内存大小，但不包括Swap和共享内存
+ SHR:共享内存大小，比如与其他进程共同使用的共享内存，加载的动态链接库以及程序的代码段等
+ %MEM: 进程使用物理内存占系统总内存的百分比

注意点：
	+ 虚拟内存通常并不会全部分配物理内存，从上面可以发现每个进程的虚拟内存逗比常驻内存大的多
	+ 共享内存SHR并不一定是共享的，比如程序的代码段，非共享的动态链接库，也都算在SHR里







